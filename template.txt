#import do_spr function
#extract asnr networks

# Set up parallel 
library(doParallel)
cores <- detectCores()
cl <- makeCluster(cores)
registerDoParallel(cl)
tmax<- 300
clusterExport(cl, c('do_spr', 'get_u_from_s', 'prepseeds', 'calculate_modularity_and_avg_module_size'))
t1s.m.1 <- list()
t1s.r.1 <- list()
t1s.r.1<- list()
all_opt_results <- list()
curr_u_list <- list()
resultsdfs<- list()

# define how many networks to first loop over
network_names <- names(extracted_networks)[50:60]

# Loop over the networks
foreach(network_name = network_names, .combine = 'c') %do% {
  library(igraph)  # Ensure igraph package is loaded in parallel workers
  network <- extracted_networks[[network_name]]

  # Generate random network
  random_network <- erdos.renyi.game(vcount(network), ecount(network), type = "gnm")

  # Calculate r
  rs <- 1 / ((mean(degree(random_network)^2) - mean(degree(random_network))) / mean(degree(random_network)))
  r_adj <- 1 - (1 - rs)^(1 / 100)  # Assuming t_R0 = 100

  # Generate distribution of infection times
  t1s.r.1 <- foreach(i = 1:100, .combine = c) %do% {
    res1.r.1 <- do_spr(net = random_network, type = "infected", n_seeds = nseeds, loc_seeds = locseeds, s = r_adj,tmax = tmax, returnnets = FALSE, verbose = FALSE, inform.type = "conformist")
    sort(sum(res1.r.1$infected), na.last = TRUE)
  }
#use optimise of function that will find spreading parameter value
opt_results <- foreach(i=1:3) %do% { 
  stats::optimize(get_u_from_s, interval = c(0, 1), rnet = random_network, infres = t1s.r.1)
}

all_opt_results[[network_name]] <- opt_results

# Find the u value that minimizes bhs
min_bhs_index <- which.min(sapply(opt_results, function(x) x$objective))
min_u <- opt_results[[min_bhs_index]]$minimum

# Store the u value that minimizes bhs in curr_u_list
curr_u_list[[network_name]] <- min_u

#do information spread at that curr_u
t1s.r.2 <- foreach(i=1:100, .combine=c, .packages="igraph") %do% {
  res1.r.2 <- do_spr(net=random_network, type="informed", inform.type="conformist", min_learn=0.001, n_seeds=nseeds, loc_seeds=locseeds, u=min_u, tmax=tmax, returnnets=FALSE, verbose=FALSE)
  sort(sum(res1.r.2$informed, na.last=TRUE))
}
    #simulate spread of disease and information 50 times in the real netwrok
  t1s.m.1 <- foreach(i = 1:100, .combine = rbind, .packages = "igraph") %dopar% {
    res1.m.1 <- do_spr(net = network, type = "both", n_seeds = nseeds, inform.type = "conformist", min_learn = 0.001, loc_seeds = locseeds, s = r_adj, u = min_u, tmax = tmax, returnnets = FALSE, verbose = FALSE)

    data.frame(network = network_name, numinfected = sort(sum(res1.m.1$infected, na.last = TRUE)), numinformed = sort(sum(res1.m.1$informed, na.last = TRUE)))
  }

# Get some network characteristics
modularity_and_avg_module_size <- calculate_modularity_and_avg_module_size(network)
modularity_score <- modularity_and_avg_module_size$modularity
avg_module_size <- modularity_and_avg_module_size$avg_module_size

# Store network-level results in resultdf
resultdf <- data.frame(
  infected.mean = mean(t1s.m.1$numinfected, na.rm = TRUE),
  infected.sd = sd(t1s.m.1$numinfected, na.rm = TRUE),
  informed.mean = mean(t1s.m.1$numinformed, na.rm = TRUE),
  informed.sd = sd(t1s.m.1$numinformed, na.rm = TRUE),
  bhs = bhatt_coef(as.vector(t1s.m.1$numinfected), as.vector(t1s.m.1$numinformed)),
  modularity = modularity_score,
  avg_module_size = avg_module_size,
  chosenu = min_u,
  r_infected_mean = mean(t1s.r.1, na.rm = TRUE),
  r_infected_sd = sd(t1s.r.1, na.rm = TRUE),
  r_informed_mean = mean(t1s.r.2, na.rm = TRUE),
  r_informed_sd = sd(t1s.r.2, na.rm = TRUE),
   r_bhs = bhatt_coef(as.vector(t1s.r.1), as.vector(t1s.r.2))
)

# Store the result for each network
resultsdfs[[network_name]] <- resultdf
}

final_resultdf <- do.call(rbind, resultsdfs)
# Clean up parallel backend
stopCluster(cl)
